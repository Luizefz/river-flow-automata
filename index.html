<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Autômato de Gás de Rede FHP</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Warm Neutrals with Blue Accent -->
    <!-- Application Structure Plan: A two-column layout is used for clear separation of concerns. The main content area on the left is dedicated to the large canvas visualization for maximum impact and focus. The right-hand sidebar contains all user controls and explanatory text, organized into logical groups (simulation control, parameters, theory). This structure is intuitive, keeps the visualization uncluttered, and allows users to reference rules while observing the simulation. The user flow is: Observe -> Control -> Interact (Paint) -> Observe, creating an engaging feedback loop. -->
    <!-- Visualization & Content Choices: 
        - Report Info: FHP particle simulation on a hexagonal grid. Goal: Visualize micro-interactions leading to macro fluid dynamics. Viz/Method: Two stacked HTML5 Canvases. A static background canvas for the grid (drawn once for performance) and a dynamic foreground canvas for particles/walls (redrawn each frame). Interaction: Direct mouse painting on the canvas to set initial conditions (walls/particles), providing immediate tactile feedback. Justification: This is the most direct and performant way to render this type of simulation on the web, and direct interaction is highly engaging. Library: Vanilla JS Canvas API.
        - Report Info: Simulation parameters (speed, density). Goal: Allow user control. Viz/Method: HTML sliders and buttons. Interaction: JS event listeners update simulation state. Justification: Standard, intuitive UI controls.
        - Report Info: FHP collision rules. Goal: Educate the user. Viz/Method: Formatted HTML text in the sidebar. Interaction: Static reading. Justification: Keeps the theory accessible alongside the live simulation.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');

        .app-container {
            display: flex;
            flex-direction: row;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        .simulation-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        #canvas-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1200px;
            max-height: 1200px;
            aspect-ratio: 1 / 1;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #background-canvas {
            z-index: 1;
        }

        #simulation-canvas {
            z-index: 2;
            cursor: crosshair;
        }

        .controls-container {
            flex-shrink: 0;
            width: 340px;
        }

        @media (max-width: 900px) {
            .app-container {
                flex-direction: column;
                height: auto;
                overflow: auto;
            }

            .controls-container {
                width: 100%;
                border-left: none;
                border-top: 1px solid #e5e7eb;
            }

            .simulation-container {
                height: 65vh;
                min-height: 300px;
            }
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-800">
    <div class="app-container">
        <main class="simulation-container bg-gray-100">
            <div id="canvas-wrapper">
                <canvas id="background-canvas"></canvas>
                <canvas id="simulation-canvas"></canvas>
            </div>
        </main>
        <aside class="controls-container bg-white p-6 overflow-y-auto border-l border-gray-200">
            <div class="max-w-md mx-auto">
                <h1 class="text-2xl font-bold text-gray-900">Simulador FHP</h1>
                <p class="mt-1 text-sm text-gray-600">Visualização de dinâmica de fluidos com um Autômato de Gás de Rede
                    em uma grade hexagonal.</p>

                <div class="mt-8 space-y-6">
                    <section>
                        <h2 class="text-lg font-semibold text-gray-700">Controle da Simulação</h2>
                        <div class="mt-4 flex items-center space-x-3">
                            <button id="play-pause-btn"
                                class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors">Play</button>
                            <button id="reset-btn"
                                class="w-full bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg shadow-sm hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 transition-colors">Reset</button>
                        </div>
                        <div class="mt-4">
                            <label for="speed-slider" class="block text-sm font-medium text-gray-700">Velocidade: <span
                                    id="speed-value" class="font-bold">15</span> passos/s</label>
                            <input type="range" id="speed-slider" min="1" max="100" value="15"
                                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2">
                        </div>
                    </section>

                    <section>
                        <h2 class="text-lg font-semibold text-gray-700">Parâmetros Iniciais</h2>
                        <div class="mt-4">
                            <label for="density-slider" class="block text-sm font-medium text-gray-700">Densidade
                                Inicial: <span id="density-value" class="font-bold">0.20</span></label>
                            <input type="range" id="density-slider" min="0.05" max="0.5" step="0.01" value="0.20"
                                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2">
                        </div>
                        <div class="mt-4">
                            <p class="text-sm font-medium text-gray-700">Modo de Interação:</p>
                            <div class="mt-2 flex items-center space-x-4">
                                <label class="flex items-center space-x-2 text-sm">
                                    <input type="radio" name="paint-mode" value="particles" checked
                                        class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                    <span>Partículas</span>
                                </label>
                                <label class="flex items-center space-x-2 text-sm">
                                    <input type="radio" name="paint-mode" value="wall"
                                        class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                    <span>Parede</span>
                                </label>
                            </div>
                        </div>
                    </section>

                    <section>
                        <h2 class="text-lg font-semibold text-gray-700">Como Funciona?</h2>
                        <div class="mt-3 text-sm text-gray-600 space-y-3">
                            <p>Este simulador implementa o modelo <strong>Frisch-Hasslacher-Pomeau (FHP)</strong>.
                                Partículas digitais se movem e colidem em uma grade hexagonal, seguindo regras que
                                conservam massa e momento, gerando um comportamento macroscópico similar ao de um
                                fluido.</p>
                            <div>
                                <h3 class="font-semibold text-gray-700">Regras de Colisão (FHP-I)</h3>
                                <ul class="list-disc list-inside mt-1 space-y-1">
                                    <li><strong>Colisão Frontal (2 corpos):</strong> Duas partículas colidindo de frente
                                        se espalham com um ângulo de +/- 60 graus. A escolha da direção de saída é
                                        aleatória (estocástica).</li>
                                    <li><strong>Colisão Tripla (3 corpos):</strong> Três partículas em uma colisão
                                        simétrica invertem suas direções.</li>
                                </ul>
                            </div>
                            <div>
                                <h3 class="font-semibold text-gray-700">Condições de Fronteira</h3>
                                <p>Paredes usam a regra de "bounce-back": uma partícula que atinge uma parede tem sua
                                    velocidade invertida, retornando pelo caminho de onde veio.</p>
                            </div>
                        </div>
                    </section>
                </div>
            </div>
        </aside>
    </div>

    <script type="module">
        class Hex {
            constructor(q, r) {
                this.q = q;
                this.r = r;
                this.s = -q - r;
            }

            static directions = [
                new Hex(1, 0), new Hex(1, -1), new Hex(0, -1),
                new Hex(-1, 0), new Hex(-1, 1), new Hex(0, 1)
            ];

            neighbor(direction) {
                const dir = Hex.directions[direction];
                return new Hex(this.q + dir.q, this.r + dir.r);
            }

            toString() {
                return `${this.q},${this.r}`;
            }
        }

        class Layout {
            constructor(origin, size) {
                this.origin = origin;
                this.size = size;
            }

            hexToPixel(hex) {
                const x = this.size.x * (Math.sqrt(3) * hex.q + Math.sqrt(3) / 2 * hex.r);
                const y = this.size.y * (3. / 2 * hex.r);
                return { x: x + this.origin.x, y: y + this.origin.y };
            }

            pixelToHex(p) {
                const pt = { x: (p.x - this.origin.x) / this.size.x, y: (p.y - this.origin.y) / this.size.y };
                const q = (Math.sqrt(3) / 3 * pt.x - 1. / 3 * pt.y);
                const r = (2. / 3 * pt.y);
                return this.hexRound(new Hex(q, r));
            }

            hexRound(hex) {
                let q = Math.round(hex.q);
                let r = Math.round(hex.r);
                let s = Math.round(hex.s);

                const q_diff = Math.abs(q - hex.q);
                const r_diff = Math.abs(r - hex.r);
                const s_diff = Math.abs(s - hex.s);

                if (q_diff > r_diff && q_diff > s_diff) {
                    q = -r - s;
                } else if (r_diff > s_diff) {
                    r = -q - s;
                } else {
                    s = -q - r;
                }
                return new Hex(q, r);
            }

            hexCornerOffset(corner) {
                const angle = 2.0 * Math.PI / 6 * (corner + 0.5); // Pointy-top
                return { x: this.size.x * Math.cos(angle), y: this.size.y * Math.sin(angle) };
            }
        }

        class Simulation {
            constructor(radius) {
                this.radius = radius;
                this.grid = new Map();
                this.tempGrid = new Map();
                this.walls = new Set();
                this.collisionLUT = this.createCollisionLUT();
            }

            reset(initialDensity) {
                this.grid.clear();
                this.walls.clear();
                for (let q = -this.radius; q <= this.radius; q++) {
                    const r1 = Math.max(-this.radius, -q - this.radius);
                    const r2 = Math.min(this.radius, -q + this.radius);
                    for (let r = r1; r <= r2; r++) {
                        let state = 0;
                        for (let i = 0; i < 6; i++) {
                            if (Math.random() < initialDensity) {
                                state |= (1 << i);
                            }
                        }
                        if (state > 0) {
                            this.grid.set(new Hex(q, r).toString(), state);
                        }
                    }
                }
            }

            createCollisionLUT() {
                const lut = new Array(1 << 6).fill(0);
                for (let i = 0; i < 6; i++) {
                    // Head-on collision
                    const s_headon = (1 << i) | (1 << ((i + 3) % 6));
                    const o1 = (1 << ((i + 1) % 6)) | (1 << ((i + 4) % 6));
                    const o2 = (1 << ((i + 5) % 6)) | (1 << ((i + 2) % 6));
                    lut[s_headon] = [o1, o2];

                    // 3-body symmetric collision
                    const s_3body = (1 << i) | (1 << ((i + 2) % 6)) | (1 << ((i + 4) % 6));
                    const o_3body = (1 << ((i + 1) % 6)) | (1 << ((i + 3) % 6)) | (1 << ((i + 5) % 6));
                    lut[s_3body] = o_3body;
                }
                return lut;
            }

            setWall(hex, isWall) {
                const key = hex.toString();
                if (isWall) {
                    this.walls.add(key);
                    this.grid.delete(key);
                } else {
                    this.walls.delete(key);
                }
            }

            addParticles(hex, density) {
                const key = hex.toString();
                if (this.walls.has(key)) return;

                let state = this.grid.get(key) || 0;
                for (let i = 0; i < 6; i++) {
                    if (Math.random() < density) {
                        state |= (1 << i);
                    }
                }
                if (state > 0) {
                    this.grid.set(key, state);
                }
            }

            step() {
                this.collide();
                this.propagate();
            }

            collide() {
                this.tempGrid.clear();
                for (const [key, state] of this.grid.entries()) {
                    let outState = this.collisionLUT[state];
                    if (Array.isArray(outState)) {
                        outState = outState[Math.floor(Math.random() * outState.length)];
                    } else if (outState === 0) {
                        outState = state;
                    }

                    // Handle spectator particles
                    let particles = state;
                    let colliding_particles = 0;
                    this.collisionLUT.forEach((value, index) => {
                        if ((state & index) === index && index > colliding_particles) {
                            colliding_particles = index;
                        }
                    });

                    if (colliding_particles > 0) {
                        let spectators = state & ~colliding_particles;
                        let result = this.collisionLUT[colliding_particles];
                        if (Array.isArray(result)) {
                            result = result[Math.floor(Math.random() * result.length)];
                        }
                        outState = result | spectators;
                    } else {
                        outState = state;
                    }

                    if (outState > 0) {
                        this.tempGrid.set(key, outState);
                    }
                }
                [this.grid, this.tempGrid] = [this.tempGrid, this.grid];
            }

            propagate() {
                this.tempGrid.clear();
                for (const [key, state] of this.grid.entries()) {
                    const [q, r] = key.split(',').map(Number);
                    const currentHex = new Hex(q, r);

                    for (let i = 0; i < 6; i++) {
                        if ((state >> i) & 1) {
                            const neighborHex = currentHex.neighbor(i);
                            const neighborKey = neighborHex.toString();

                            if (this.walls.has(neighborKey)) {
                                const bounceBackDir = (i + 3) % 6;
                                this.tempGrid.set(key, (this.tempGrid.get(key) || 0) | (1 << bounceBackDir));
                            } else {
                                this.tempGrid.set(neighborKey, (this.tempGrid.get(neighborKey) || 0) | (1 << i));
                            }
                        }
                    }
                }
                [this.grid, this.tempGrid] = [this.tempGrid, this.grid];
            }
        }

        class Renderer {
            constructor(bgCanvas, simCanvas, layout) {
                this.bgCanvas = bgCanvas;
                this.simCanvas = simCanvas;
                this.bgCtx = bgCanvas.getContext('2d', { alpha: false });
                this.simCtx = simCanvas.getContext('2d');
                this.layout = layout;
                this.particleColor = '#2563eb';
                this.wallColor = '#374151';
            }

            resize(width, height) {
                this.bgCanvas.width = width;
                this.bgCanvas.height = height;
                this.simCanvas.width = width;
                this.simCanvas.height = height;
                this.layout.origin = { x: width / 2, y: height / 2 };
            }

            drawGrid(radius) {
                this.bgCtx.clearRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);
                this.bgCtx.fillStyle = '#f9fafb';
                this.bgCtx.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height);

                this.bgCtx.strokeStyle = '#e5e7eb';
                this.bgCtx.lineWidth = 1;

                for (let q = -radius; q <= radius; q++) {
                    const r1 = Math.max(-radius, -q - radius);
                    const r2 = Math.min(radius, -q + radius);
                    for (let r = r1; r <= r2; r++) {
                        const hex = new Hex(q, r);
                        const center = this.layout.hexToPixel(hex);
                        this.bgCtx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const corner = this.layout.hexCornerOffset(i);
                            const p = { x: center.x + corner.x, y: center.y + corner.y };
                            if (i === 0) this.bgCtx.moveTo(p.x, p.y);
                            else this.bgCtx.lineTo(p.x, p.y);
                        }
                        this.bgCtx.closePath();
                        this.bgCtx.stroke();
                    }
                }
            }

            draw(simulation) {
                this.simCtx.clearRect(0, 0, this.simCanvas.width, this.simCanvas.height);

                this.simCtx.fillStyle = this.wallColor;
                for (const key of simulation.walls) {
                    const [q, r] = key.split(',').map(Number);
                    const hex = new Hex(q, r);
                    const center = this.layout.hexToPixel(hex);
                    this.simCtx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const corner = this.layout.hexCornerOffset(i);
                        const p = { x: center.x + corner.x, y: center.y + corner.y };
                        if (i === 0) this.simCtx.moveTo(p.x, p.y);
                        else this.simCtx.lineTo(p.x, p.y);
                    }
                    this.simCtx.closePath();
                    this.simCtx.fill();
                }

                this.simCtx.strokeStyle = this.particleColor;
                this.simCtx.lineWidth = Math.max(1.5, this.layout.size.x * 0.2);

                for (const [key, state] of simulation.grid.entries()) {
                    const [q, r] = key.split(',').map(Number);
                    const hex = new Hex(q, r);
                    const center = this.layout.hexToPixel(hex);

                    for (let i = 0; i < 6; i++) {
                        if ((state >> i) & 1) {
                            const directionVector = Hex.directions[i];
                            const start = { x: center.x, y: center.y };
                            const end = {
                                x: center.x + directionVector.q * this.layout.size.x * 0.866 * 0.7,
                                y: center.y + (directionVector.r * 1.5 + directionVector.q * 0.866) * this.layout.size.y * 0.5 * 0.7
                            };
                            this.simCtx.beginPath();
                            this.simCtx.moveTo(start.x, start.y);
                            this.simCtx.lineTo(end.x, end.y);
                            this.simCtx.stroke();
                        }
                    }
                }
            }
        }

        class UI {
            constructor(simulation, renderer) {
                this.sim = simulation;
                this.renderer = renderer;
                this.playPauseBtn = document.getElementById('play-pause-btn');
                this.resetBtn = document.getElementById('reset-btn');
                this.speedSlider = document.getElementById('speed-slider');
                this.speedValue = document.getElementById('speed-value');
                this.densitySlider = document.getElementById('density-slider');
                this.densityValue = document.getElementById('density-value');
                this.paintModeRadios = document.querySelectorAll('input[name="paint-mode"]');

                this.isPainting = false;
                this.paintMode = 'particles';

                this.setupListeners();
            }

            setupListeners() {
                this.playPauseBtn.addEventListener('click', () => this.togglePlay());
                this.resetBtn.addEventListener('click', () => this.reset());

                this.speedSlider.addEventListener('input', () => this.updateSpeed());
                this.densitySlider.addEventListener('input', () => this.updateDensity());

                this.paintModeRadios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.paintMode = e.target.value;
                    });
                });

                const canvas = this.renderer.simCanvas;
                canvas.addEventListener('mousedown', (e) => {
                    this.isPainting = true;
                    this.handlePaint(e);
                });
                canvas.addEventListener('mousemove', (e) => {
                    if (this.isPainting) {
                        this.handlePaint(e);
                    }
                });
                document.addEventListener('mouseup', () => {
                    this.isPainting = false;
                });
                canvas.addEventListener('touchstart', (e) => {
                    this.isPainting = true;
                    this.handlePaint(e.touches[0]);
                    e.preventDefault();
                });
                canvas.addEventListener('touchmove', (e) => {
                    if (this.isPainting) {
                        this.handlePaint(e.touches[0]);
                    }
                    e.preventDefault();
                });
                document.addEventListener('touchend', () => {
                    this.isPainting = false;
                });
            }

            setCallbacks(callbacks) {
                this.callbacks = callbacks;
            }

            togglePlay() {
                if (this.playPauseBtn.textContent === 'Play') {
                    this.playPauseBtn.textContent = 'Pause';
                    this.callbacks.play();
                } else {
                    this.playPauseBtn.textContent = 'Play';
                    this.callbacks.pause();
                }
            }

            reset() {
                if (this.playPauseBtn.textContent === 'Pause') {
                    this.togglePlay();
                }
                this.callbacks.reset(parseFloat(this.densitySlider.value));
            }

            updateSpeed() {
                const speed = parseInt(this.speedSlider.value);
                this.speedValue.textContent = speed;
                this.callbacks.setSpeed(speed);
            }

            updateDensity() {
                this.densityValue.textContent = parseFloat(this.densitySlider.value).toFixed(2);
            }

            handlePaint(e) {
                const rect = this.renderer.simCanvas.getBoundingClientRect();
                const scaleX = this.renderer.simCanvas.width / rect.width;
                const scaleY = this.renderer.simCanvas.height / rect.height;
                const pixel = { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
                const hex = this.renderer.layout.pixelToHex(pixel);

                if (Math.abs(hex.q) > this.sim.radius || Math.abs(hex.r) > this.sim.radius || Math.abs(hex.s) > this.sim.radius) {
                    return;
                }

                if (this.paintMode === 'wall') {
                    this.sim.setWall(hex, true);
                } else {
                    this.sim.setWall(hex, false);
                    this.sim.addParticles(hex, 0.95);
                }
            }
        }

        class App {
            constructor() {
                this.simRadius = 35;

                const bgCanvas = document.getElementById('background-canvas');
                const simCanvas = document.getElementById('simulation-canvas');
                const wrapper = document.getElementById('canvas-wrapper');

                const hexSize = (wrapper.clientWidth / (this.simRadius * 2 * Math.sqrt(3) / 2));

                const layout = new Layout({ x: 0, y: 0 }, { x: hexSize, y: hexSize });

                this.sim = new Simulation(this.simRadius);
                this.renderer = new Renderer(bgCanvas, simCanvas, layout);
                this.ui = new UI(this.sim, this.renderer);

                this.isRunning = false;
                this.animationFrameId = null;
                this.stepsPerSecond = 15;
                this.lastUpdateTime = 0;

                this.setup();
                window.addEventListener('resize', () => this.handleResize());
            }

            setup() {
                this.handleResize();

                this.ui.setCallbacks({
                    play: () => this.play(),
                    pause: () => this.pause(),
                    setSpeed: (speed) => this.stepsPerSecond = speed,
                    reset: (density) => this.reset(density)
                });

                this.reset(parseFloat(document.getElementById('density-slider').value));
            }

            handleResize() {
                const wrapper = document.getElementById('canvas-wrapper');
                const size = Math.min(wrapper.clientWidth, wrapper.clientHeight);

                const newHexSize = (size / (this.simRadius * 2 * Math.sqrt(3) / 2));
                this.renderer.layout.size = { x: newHexSize, y: newHexSize };

                this.renderer.resize(size, size);
                this.renderer.drawGrid(this.simRadius);
                this.renderer.draw(this.sim);
            }

            reset(initialDensity) {
                this.pause();
                this.sim.reset(initialDensity);
                this.renderer.draw(this.sim);
            }

            play() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.lastUpdateTime = performance.now();
                this.animationFrameId = requestAnimationFrame((t) => this.loop(t));
            }

            pause() {
                this.isRunning = false;
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }

            loop(timestamp) {
                if (!this.isRunning) return;

                this.animationFrameId = requestAnimationFrame((t) => this.loop(t));

                const timePerStep = 1000 / this.stepsPerSecond;
                const elapsed = timestamp - this.lastUpdateTime;

                if (elapsed > timePerStep) {
                    const stepsToTake = Math.floor(elapsed / timePerStep);
                    for (let i = 0; i < stepsToTake; i++) {
                        this.sim.step();
                    }
                    this.lastUpdateTime = timestamp - (elapsed % timePerStep);
                }

                this.renderer.draw(this.sim);
            }
        }

        window.addEventListener('load', () => new App());

    </script>
</body>

</html>